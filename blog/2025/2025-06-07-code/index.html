<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h2 id="introduction">Introduction</h2> <p>I recently dedicated some time to learn some concepts of modern C++. And since I was on it why not summarizing the recent development of modern C++? The real reason is that I felt I was always using the same features of modern C++ but I felt that there were a lot of topics that I did not master or that I was not even aware of, especially in C++20.What sets C++20 apart for me is how it reshapes template programming and functional-style operations in ways that feel both futuristic and incredibly practical.</p> <p>Here is my free pdf guidebook on modern C++! <a href="/assets/pdf/modern_cpp_guide_Adam_Abed_Abud.pdf">Download the PDF here</a></p> <p>In the following section I will dive a bit deeper on the cool features of C++20.</p> <h3 id="concepts-a-giant-leap-for-template-clarity">Concepts: A Giant Leap for Template Clarity</h3> <p>Take <strong>Concepts</strong>, for example. No more cryptic template instantiation errors when you accidentally pass the wrong type. Now, you can explicitly constrain templates like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">integral</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This not only improves readability but makes your code self-documenting. The compiler’s error messages also become vastly more understandable. Finally some useful changes for template programming!</p> <h3 id="ranges-functional-elegance-meets-performance">Ranges: Functional Elegance Meets Performance</h3> <p>Another feature I found compelling was the Ranges library. With range-based views and composable pipelines, you can write expressive and clean code like:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">evenSquares</span> <span class="o">=</span> <span class="n">numbers</span> 
    <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">filter</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span>
    <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">([](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">});</span>
</code></pre></div></div> <p>It’s lazy, elegant, and highly performant—bringing C++ closer to the clarity you often see in functional languages, but without sacrificing control. This is a nice feature that I am looking forward to start experimenting with.</p> <h3 id="coroutines-asynchronous-without-the-headache">Coroutines: Asynchronous Without the Headache</h3> <p>And then there are Coroutines. They open the door to writing non-blocking, asynchronous code in a synchronous style. Imagine building a generator that produces an infinite arithmetic sequence—without threads, without state machines—just with co_yield. I still do not fully understand how to use them.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">countBy</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">step</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">co_yield</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">value</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is all powered by sophisticated compiler magic under the hood.</p> <h2 id="conclusion">Conclusion</h2> <p>I found writing this guidebook very interesting and useful for myself to review some features of C++ that I tend to not use. I feel it’s important to refresh such concepts from time to time. I hope the guide will also be useful. I used AI to compile some examples and I have to admit that I am quite satisfied on how it turned out. It was also a while I didn’t write such a technical material.</p> </body></html>